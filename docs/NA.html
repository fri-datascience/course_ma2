<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 2 NA | Mathematics 2 - exercises</title>
  <meta name="description" content="Course notes" />
  <meta name="generator" content="bookdown 0.20 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 2 NA | Mathematics 2 - exercises" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://fri-datascience.github.io/course_ma2/" />
  
  <meta property="og:description" content="Course notes" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 2 NA | Mathematics 2 - exercises" />
  
  <meta name="twitter:description" content="Course notes" />
  

<meta name="author" content="Erik Štrumbelj, Gašper Fijavž, and Žiga Virk" />


<meta name="date" content="2021-04-05" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="gradient.html"/>
<link rel="next" href="montecarlo.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />












<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Mathematics 2</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="chapter" data-level="1" data-path="gradient.html"><a href="gradient.html"><i class="fa fa-check"></i><b>1</b> Gradient-based methods</a><ul>
<li class="chapter" data-level="1.1" data-path="gradient.html"><a href="gradient.html#theoretical-problems"><i class="fa fa-check"></i><b>1.1</b> Theoretical problems</a></li>
<li class="chapter" data-level="1.2" data-path="gradient.html"><a href="gradient.html#practical-problems"><i class="fa fa-check"></i><b>1.2</b> Practical problems</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="NA.html"><a href="NA.html"><i class="fa fa-check"></i><b>2</b> NA</a><ul>
<li class="chapter" data-level="2.1" data-path="NA.html"><a href="NA.html#th02"><i class="fa fa-check"></i><b>2.1</b> Theoretical problems</a></li>
<li class="chapter" data-level="2.2" data-path="NA.html"><a href="NA.html#pr02"><i class="fa fa-check"></i><b>2.2</b> Practical problems</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="montecarlo.html"><a href="montecarlo.html"><i class="fa fa-check"></i><b>3</b> Monte Carlo</a></li>
<li class="chapter" data-level="4" data-path="markov.html"><a href="markov.html"><i class="fa fa-check"></i><b>4</b> Markov Chains</a></li>
<li class="chapter" data-level="5" data-path="MCMC.html"><a href="MCMC.html"><i class="fa fa-check"></i><b>5</b> Markov Chain Monte Carlo</a></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Mathematics 2 - exercises</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="NA" class="section level1">
<h1><span class="header-section-number">Chapter 2</span> NA</h1>
<div id="th02" class="section level2">
<h2><span class="header-section-number">2.1</span> Theoretical problems</h2>

<div class="exercise">
<p><span id="exr:unnamed-chunk-1" class="exercise"><strong>Exercise 2.1  (Bounding the unbounded)  </strong></span> Observe that maximizing the sum of coordinates in the positive quadrant of <span class="math inline">\(\mathbb{R}^2\)</span> is an unbounded linear program. However, minimizing the sum of coordinates in the same quadrant is a linear problem that has an optimal solution.</p>
Both problems have the same unbounded set of feasible solutions. There is nothing we can do for the first problem. For the problems of the second type, however, we would like to a-priori bound the coordinates so that (i) we preserve the feasibility of the problem and (ii) we do not alter the optimum. This can be done:
</div>
 
<div class="proposition">
<span id="prp:unnamed-chunk-2" class="proposition"><strong>Proposition 2.1  </strong></span>Observe the linear program
<span class="math display">\[\begin{align*}
  \min &amp;\;c^T x \\ 
       &amp;A x = b \tag{LP}\\ 
       &amp;x \ge 0,
\end{align*}\]</span>
<p>where <span class="math inline">\(A\)</span> is an <span class="math inline">\(m \times n\)</span> matrix, <span class="math inline">\(c,x\)</span> are <span class="math inline">\(n\)</span>-dimensional, and <span class="math inline">\(b\)</span> is an <span class="math inline">\(m\)</span>-dimensional vector. Assume also that the coefficients so <span class="math inline">\(A\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span> are integers and are (absolutely) bounded by <span class="math inline">\(U\)</span>. Let <span class="math inline">\(M=(m U)^m\)</span>.</p>
If <em>LP</em> is feasible, then there exists a feasible solution with all coordinates bounded by <span class="math inline">\(M\)</span>. Also, if <em>LP</em> has an optimal solution, then there exists an optimal solution.
</div>

<p>Our goal is to prove this proposition and we will do so in several steps:</p>
<ol style="list-style-type: lower-alpha">
<li><p>Observe first that we have equality constraints in <em>(LP)</em>. We know that inequality constraints can be transformed to equalities using slack variables, so <em>(LP)</em> is as general as it gets.</p></li>
<li><p>Estimate the determinant of a square matrix in terms of its coefficients and its dimension. Do not overcomplicate - the first bound that you find will probably suffice.</p></li>
<li><p>Study Cramer's rule and the conditions that allow its application.</p></li>
<li><p>Which linear systems of equalities have unique solutions? Is there always a square matrix involved?</p></li>
<li><p>Look for a feasible solution with as many 0 coordinates as possible. More precisely, let <span class="math inline">\(x^\circ\)</span> be a feasible solution whose <em>support</em> <span class="math inline">\(S\)</span> (the support of a vector is the set of nonzero indices/coordinates) is <em>containment-wise</em> minimal (we compare supports by the subset relation). Show that <span class="math inline">\(x^\circ\)</span> is unique. Assuming there is an alternative <span class="math inline">\({x^\circ}&#39;\)</span> this can be established by observing the line through <span class="math inline">\(x^\circ\)</span> and <span class="math inline">\({x^\circ}&#39;\)</span> towards the boundary of the feasbility region.</p></li>
<li><p>Repeat the same argument with an optimal solution <span class="math inline">\(x^*\)</span> (assuming that one exists), whose support is <em>containment-wise</em> minimal. It should be unique as well.</p></li>
<li><p>Finally, focus on nonzero coordinates of <span class="math inline">\(x^\circ\)</span> and <span class="math inline">\(x^*\)</span> and rewrite the constraints.</p></li>
<li><p><strong>(bonus)</strong> Assume that <span class="math inline">\(M\)</span> was just slightly larger so that it is a strict upper bound on the coordinates of some optimal solution --- maybe already the above defined <span class="math inline">\(M\)</span> is sufficiently large. Is the following reasoning valid: (i) add these extra <span class="math inline">\(M\)</span>-bounds to the description of the problem, (ii) as the feasible set is now bounded the problem has an optimal solution (even if the original one was unbounded), but (iii) if some coordinate in the optimal solution has value exactly <span class="math inline">\(M\)</span>, then we know that the original problem was unbounded.</p></li>
<li><p><strong>(bonus)</strong> Is <em>(d)</em> justified? Couldn't we manage with a solution that has the maximal <em>number</em> of zeros? Do we really need to compare supports by inclusion? Is a feasible solution with smallest number of nonzero coordinates unique or not? ```</p></li>
</ol>

<div class="exercise">
<span id="exr:unnamed-chunk-3" class="exercise"><strong>Exercise 2.2  (Analytic center)  </strong></span>Let
<span class="math display">\[\begin{equation}
A x \le b
\label{sys}
\end{equation}\]</span>
<p>be a system of <span class="math inline">\(n\)</span> linear inequalities, and let <span class="math inline">\(\Phi=\{x; Ax \le b\}\)</span> be the set of its <em>feasible solutions</em>. We denote <span class="math inline">\(s(x)= b-Ax\)</span>. Let <span class="math inline">\(I \subseteq \{1,\ldots,n\}\)</span> be the set of coordinates/indices, for which there exists <span class="math inline">\(x \in \Phi\)</span>, so that <span class="math inline">\((Ax)_i &lt; b_i\)</span> or equivalently <span class="math inline">\(s(x)_i &gt;0\)</span>. Note that <span class="math inline">\(x_i\)</span> is the <span class="math inline">\(i\)</span>-th coordinate of <span class="math inline">\(x \in \mathbb{R}^n\)</span>.</p>
<p>The vector <span class="math inline">\(x \in \Phi\)</span> which maximizes</p>
<p><span class="math display">\[\prod_{i \in I} s(x)_i\]</span> is called the <em>analytic center</em> of a system of linear inequalitie.</p>
<ol style="list-style-type: lower-alpha">
<li>Show that the analytic center vector is unique.</li>
<li>Show that there exists <span class="math inline">\(x \in \Phi\)</span> so that for all <span class="math inline">\(i\in I\)</span> we have <span class="math inline">\(s(x)_i &gt; 0\)</span>.</li>
<li>Show that the analytic center optimization problem is equivalent to a strictly convex optimization problem.</li>
<li>Find the analytic center for the following system of linear inequalities:
<span class="math display">\[\begin{align*}
  2 v_1 + 2 v_2 \le&amp;\; 480 \\
  3 v_1 + 1 v_2 \le&amp;\; 600 \\
  v_1 \ge&amp;\; 0 \\
  v_2 \ge&amp;\; 0 \\
  \end{align*}\]</span></li>
<li>Further constrain <em>(d)</em> with <span class="math inline">\(2 v_1 + 2 v_2 \le 600\)</span>. This additional constraint does not change the set of feasible solutions, does it change the analytic center?<br />
</li>
<li>Let <span class="math inline">\(a\)</span> be a positive real. Find the analytic centre of
<span class="math display">\[\begin{eqnarray*}
-x_1 &amp;\le 0 \\
-x_2 &amp;\le 0 \\
a x_1 + x_2 &amp;\le 1 .
\end{eqnarray*}\]</span></li>
<li>Find the analytic center of this system of linear inequalities:
<span class="math display">\[\begin{eqnarray*}
-x_1 &amp;\le 0 \\
-x_2 &amp;\le 0 \\
x_1 + x_2 &amp;\le 1\\ 
x_1 + x_2 &amp;\le 1.
\end{eqnarray*}\]</span></li>
<li><strong>(bonus)</strong> When discussing the interior point method for solving LP we defined the <em>central path</em>. Is the initial solution (an all 1s vector) incidentally also the analytic center?
</div>
</li>
</ol>

<div class="exercise">
<p><span id="exr:unnamed-chunk-4" class="exercise"><strong>Exercise 2.3  (Vertices of matching polytope)  </strong></span>Let <span class="math inline">\(\Psi\)</span> be a convex set in <span class="math inline">\(\mathbb{R}^d\)</span>. We call <span class="math inline">\(x \in \Psi\)</span> a <em>vertex</em> (also an *extremal point<em>) of <span class="math inline">\(\Psi\)</span> if <span class="math inline">\(x\)</span> cannot be expressed as a </em>proper convex combination* of <span class="math inline">\(x_1,x_2 \in \Psi\setminus\{x\}\)</span>. A proper convex combination of <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span> is an expression <span class="math inline">\(\lambda x_1 + (1-\lambda) x_2\)</span> where <span class="math inline">\(\lambda \in (0,1)\)</span>. Equivalently, <span class="math inline">\(x\)</span> is a vertex of <span class="math inline">\(\Psi\)</span> if <span class="math inline">\(\Psi\setminus \{x\}\)</span> is convex.</p>
<p>Let <span class="math inline">\(G=(V,E)\)</span> be a simple (undirected, finite) graph. A <em>matching</em> in <span class="math inline">\(G\)</span> is a set of edges <span class="math inline">\(M\)</span> which have no vertices in common. The <em>maximal matching</em> problem is an optimization problem looking for a matching of maximal cardinality.</p>
<p>The maximal matching problem can be described as a constraint satisfaction problem in the following way:</p>
<span class="math display">\[\begin{align*}
  \max &amp;\;e^T x \\ 
    &amp;\text{where for all $v \in V$ we have } \sum_{i \in E(v)} x_i \le 1, \text{ and}  \tag{MM} \\ 
    &amp;x \in \{0,1\}^E.
\end{align*}\]</span>
<p>In the above <span class="math inline">\(e\)</span> stands for the all 1s vector and <span class="math inline">\(E(v)\)</span> is the set of edges incident with a vertex <span class="math inline">\(v\)</span>.</p>
<p>The maximal matching problem can be linearly relaxed to</p>
<span class="math display">\[\begin{align*}
  \max &amp;\;e^T x \\ 
    &amp;\text{where for all $v \in V$ we have } \sum_{i \in E(v)} x_i \le 1, \text{ and} \tag{MM-LR} \\ 
    &amp;x \in [0,1]^E,
\end{align*}\]</span>
<p>allowing nonintegral coordinates in <span class="math inline">\(x\)</span>. The feasible set in (MM-LR) is called a <em>matching polytope</em>.</p>
<ol style="list-style-type: lower-alpha">
<li>Show that matchings are extremal points of the matching polytope.</li>
<li>Show that there may exist extremal points of the matching polytope which are not matchings (focus on nonbipartite graphs).</li>
<li><strong>(bonus)</strong> Many edge-disjoint <span class="math inline">\(s-t\)</span> paths problem takes a graph <span class="math inline">\(G\)</span> and its pair of vertices <span class="math inline">\(s,t\)</span> as input. The solution is a maximal (in terms of cardinality) collection of <em>edge-disjoint</em> <span class="math inline">\(s-t\)</span> paths in <span class="math inline">\(G\)</span>. What is a linear relaxation to this problem? Can it be further generalized by introducing weights on edges?
</div>
</li>
</ol>
</div>
<div id="pr02" class="section level2">
<h2><span class="header-section-number">2.2</span> Practical problems</h2>

<div class="exercise">
<p><span id="exr:unnamed-chunk-5" class="exercise"><strong>Exercise 2.4  (The Nelder-Mead method)  </strong></span>Implement the Nelder-Mead optimization method in three dimensions and compare its performance with gradient descent, AdaGrad, Newton's method, and BFGS on</p>
<ol style="list-style-type: lower-alpha">
<li><span class="math inline">\(f(x,y,z) = (x-z)^2 + (2y+z)^2 + (4x-2y+z)^2 + x + y\)</span> and</li>
<li><span class="math inline">\(f(x,y,z) = (x-1)^2+(y-1)^2+100(y-x^2)^2+100(z-y^2)^2.\)</span></li>
</ol>
<p>The comparison should be quantitative: measure and compare the quality of the solution over time. Explore the effect of different starting values.</p>
<ol start="3" style="list-style-type: lower-alpha">
<li><strong>(bonus)</strong> How does the performance of gradient-based methods change if you derive and use analytical instead of numerical gradients.
</div>
</li>
</ol>

<div class="exercise">
<p><span id="exr:unnamed-chunk-6" class="exercise"><strong>Exercise 2.5  (Black-box optimization)  </strong></span>You are given three personalized functions</p>
<p><span class="math display">\[f_{\text{ID},i}: \mathbb{R}^3 \rightarrow \mathbb{R},\]</span></p>
<p>where <span class="math inline">\(i \in \{1,2,3\}\)</span> and <em>ID</em> is your Student ID number (assumed to be a positive integer).</p>
<p>The archive XX contains Windows, Linux, and Mac OS command line executables that allow you to evaluate these functions. The command line call contains 5 parameters (<em>ID</em>, <span class="math inline">\(i\)</span>, <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, <span class="math inline">\(z\)</span>) and returns the function value <span class="math inline">\(f_{\text{ID},i}(x, y, z)\)</span>. These problems are in theory unconstrained, but you are guaranteed that none of the calls results in an overflow if real parameters lie in <span class="math inline">\([-10,10]\)</span>.</p>
<p>Example call:</p>
<blockquote>
<p>_mac 63020161 1 3.17 0.71 -1.55</p>
</blockquote>
<ol style="list-style-type: lower-alpha">
<li>Using the Nelder-Mead method find the minumum of <span class="math inline">\(f_{\text{ID},1}\)</span>, <span class="math inline">\(f_{\text{ID},2}\)</span>, and <span class="math inline">\(f_{\text{ID},3}\)</span>, where <em>ID</em> is your Student ID.</li>
<li>How would one use a gradient-descent based method in such a case. Which one is best suitable. Can you beat Nelder-Mead?
</div>
</li>
</ol>

<div class="exercise">
<p><span id="exr:unnamed-chunk-7" class="exercise"><strong>Exercise 2.6  (A Local Search study)  </strong></span>The <em>minimum spanning tree</em> (MST) problem is a well known optimization problem formally defined as</p>
<p><span class="math display">\[\\[0.2in]\]</span></p>
<div style="white-space: pre-line;"><strong>INPUT:</strong> graph <span class="math inline">\(G\)</span> with edge weights <span class="math inline">\(w: E(G) \rightarrow \mathbb{R}^+\)</span>;
<strong>OUTPUT:</strong> (weight of) spanning tree <span class="math inline">\(T\)</span>, such that <span class="math inline">\(\sum_{e \in E(T)} w(e)\)</span> is the smallest possible;</div>
<p><span class="math display">\[\\[0.2in]\]</span></p>
<ol style="list-style-type: lower-alpha">
<li>Show that if <span class="math inline">\(w\)</span> is injective, then the miminum spanning tree of a graph is <em>uniquely</em> defined. Hint: Assuming that your preferred MST algorithm correctly computes a spanning tree, show that there is no ambiguity which edges to use and which edges are not needed for the spanning tree construction.</li>
</ol>
<p><span class="math display">\[\\[0.2in]\]</span></p>
<p>Local search A local search approach to computing the of a graph could be described as follows:</p>
<div style="white-space: pre-line;"><strong>INPUT:</strong> weighted graph <span class="math inline">\(G\)</span>, initial spanning tree <span class="math inline">\(T\)</span>;
<strong>OUTPUT:</strong> spanning tree <span class="math inline">\(T&#39;\)</span>;

1: <span class="math inline">\(T&#39; = T\)</span>
2: <strong>WHILE</strong> terminating condition isn't met:
3: choose <span class="math inline">\(e_{out} \in E(T&#39;)\)</span>;
4: choose <span class="math inline">\(e_{in} \in E(G) \setminus E(T&#39;)\)</span>;
5: <strong>IF</strong> <span class="math inline">\(T&#39;-e_{out} + e_{in}\)</span> is better than <span class="math inline">\(T&#39;\)</span> <strong>THEN</strong> <span class="math inline">\(T&#39;= T&#39;-e_{out}+e_{in}\)</span>
6: <strong>RETURN</strong> <span class="math inline">\(T&#39;\)</span></div>
<p>Let us focus on lines 2 and 3. The choice of the outgoing edge <span class="math inline">\(e_{out}\)</span> can be made in several ways. We can take a random edge from <span class="math inline">\(E(T&#39;)\)</span> or we can choose a particularly bad edge --- an edge of <span class="math inline">\(E(T&#39;)\)</span> having maximal weight. Similarly the incoming edge <span class="math inline">\(e_{in}\)</span> can either be chosen at random or as the appropriate edge with smallest possible weight. Clearly <span class="math inline">\(e_{in}\)</span> should have endvertices in different components of <span class="math inline">\(T&#39;-e_{out}\)</span>, otherwise <span class="math inline">\(T&#39;-e_{out}+e_{in}\)</span> is not a tree. This makes four different next-step strategies.</p>
<p>Let <span class="math inline">\(G_{20}\)</span> be a <span class="math inline">\(20 \times 20\)</span> --- the vertex set consists of integral points in the plane with coordinates between <span class="math inline">\(1\)</span> and <span class="math inline">\(20\)</span>, vertices at distance <span class="math inline">\(1\)</span> being adjacent. Let <span class="math inline">\(T_{20}\)</span> be its arbitrary, but fixed spanning tree. For example, <span class="math inline">\(T_{20}\)</span> can be the union of all horizontal paths together with the leftmost vertical one. A routine computation shows that <span class="math inline">\(G_{20}\)</span> contains exactly <span class="math inline">\(760\)</span> edges and <span class="math inline">\(T_{20}\)</span>, no matter which one you choose, contains <span class="math inline">\(399\)</span> edges.</p>
<ol start="2" style="list-style-type: lower-alpha">
<li><p>Choose a random injective edge-weights function <span class="math inline">\(w:E(G) \rightarrow \{1,\ldots,760\}\)</span> for <span class="math inline">\(G_{20}\)</span> and compute the minimum spanning tree <span class="math inline">\(T_{mst}\)</span> with respect to <span class="math inline">\(w\)</span> --- use a library call/built in routine in your preferred programming environment. Note also its weight.</p></li>
<li><p>Starting with initial spanning tree <span class="math inline">\(T_{20}\)</span>, try all four described local search approaches. Does a particular approach converge to <span class="math inline">\(T_{mst}\)</span>? If so, how fast? How many edge-swaps have you preformed until you reach <span class="math inline">\(T_{mst}\)</span>?</p></li>
<li><p>Repeat <em>(c)</em> above for several alternative choices of such edge weights.</p></li>
<li><p><strong>(bonus)</strong> Can you make efficient random choices in large scale applications? Choosing a random element of a linear array seems easy, but do we really have such arrays at our disposal?</p></li>
<li><p><strong>(bonus)</strong> We have focused on four next-step strategies. Can you think of a sensible qualitatively different alternative strategy?</p></li>
<li><strong>(bonus)</strong> A <em>Minimal bottleneck spanning tree (MBST)</em> of a graph <span class="math inline">\(G\)</span> is a spanning tree in which the heaviest edge (bottleneck) is as light as possible. Is there an easy way to compute a MBST of a graph? Why? How?
</div>
</li>
</ol>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="gradient.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="montecarlo.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
